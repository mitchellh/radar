require 'forwardable'

module Radar
  # The configuration class used for applications. To configure your application
  # see {Application#config}. This is also where all the examples are.
  class Config
    attr_reader :reporters
    attr_reader :data_extensions
    attr_reader :matchers
    attr_reader :rejecters
    attr_reader :filters
    attr_accessor :log_location

    def initialize
      @reporters       = UseArray.new(&method(:add_reporter))
      @data_extensions = UseArray.new(&method(:add_data_extension))
      @matchers        = UseArray.new(&method(:add_matcher))
      @rejecters       = UseArray.new(&method(:add_matcher))
      @filters         = UseArray.new(&method(:add_filter))
      @log_location    = nil

      @data_extensions.use DataExtensions::HostEnvironment
    end

    # Adds a reporter to the application. Unlike most exception notifiers,
    # Radar on its own doesn't actually do anything with the exception data
    # once it has processed it. Instead, it is up to reporters to take the
    # exception data and do something with it. Using this method, you can
    # enable reporters.
    #
    # Built-in reporters can be accessed via a symbol:
    #
    #     config.reporter :file
    #
    # Custom reporters can be accessed via a class:
    #
    #     config.reporter MyCustomReporter
    #
    # And for simple reporters, you may even just use a block:
    #
    #     config.reporter do |event|
    #       # Do something with the event
    #     end
    #
    # Any arguments other than the first, including any given blocks,
    # are passed on to the reporter class.
    def reporter(*args, &block)
      @reporters.use(*args, &block)
    end

    # Adds a data extension to the application. By default, the exception
    # data generated by Radar is quite lean and only includes the basic
    # information about the application and exception. Through the use
    # of data extensions, you can add any sort of information to the
    # exception data that you want.
    #
    # Built-in data extensions can be enabled via a symbol:
    #
    #     config.data_extension :host_environment
    #
    # Custom data extensions can be enabled via a class:
    #
    #     config.data_extension MyCustomExtension
    #
    # Any arguments given will be passed on to the data extension class.
    def data_extension(*args, &block)
      @data_extensions.use(*args, &block)
    end

    # Adds a matcher rule to the application. An application will only
    # report an exception if the event agrees with at least one of the
    # matchers.
    #
    # To use a matcher, there are two options. The first is to use a
    # symbol for the name:
    #
    #     config.match :class, StandardError
    #
    # This will cause Radar to search for a class named "ClassMatcher"
    # under the namespace {Radar::Matchers}.
    #
    # A second option is to use a class itself:
    #
    #     config.match Radar::Matchers::ClassMatcher, StandardError
    #
    # Radar will then use the specified class as the matcher.
    def match(*args, &block)
      @matchers.use(*args, &block)
    end

    # Adds a rejecter rule to the application. A rejecter is the same as a
    # matcher, so if you're not familiar with matchers, please read the documentation
    # above {#match} first. The only difference with a rejecter is that if
    # any of the rejecters return true, then the exception event is not sent
    # to reporters.
    #
    # Another important note is that rejecters always take precedence over
    # matchers. So even if a matcher would have matched the exception, if it
    # matches a rejecter, then it won't continue.
    def reject(*args, &block)
      @rejecters.use(*args, &block)
    end

    # Adds a filter to the application. Filters provide a method of filtering
    # the exception data just prior to the data being sent to the reporters.
    # This enables you to filter out sensitive information such as passwords,
    # or even just to remove unnecessary keys.
    #
    # Built-in filters can be enabled using a symbol shortcut:
    #
    #     config.filter :key, :key => :password
    #
    # Custom filters can be enabled using a class:
    #
    #     config.filter MyCustomFilter
    #
    # Or simple filters can be created using lambda functions:
    #
    #     config.filter do |data|
    #       # do something with the data and return it
    #       data
    #     end
    #
    # Any arguments given will be passed on to the filter class.
    def filter(*args, &block)
      @filters.use(*args, &block)
    end

    protected

    # The callback that is used to add a reporter to the {UseArray}
    # when `reporters.use` is called.
    def add_reporter(*args)
      callable_method(:report, "Radar::Reporter::%sReporter", *args)
    end

    # The callback that is used to add a data extension to the {UseArray}
    # when `data_extensions.use` is called.
    def add_data_extension(ext, *args)
      ext = Support::Inflector.constantize("Radar::DataExtensions::#{Support::Inflector.camelize(ext)}") if !ext.is_a?(Class)
      [ext, ext]
    end

    # The callback that is used to add a matcher to the {UseArray}
    # when `matchers.use` is called.
    def add_matcher(*args)
      callable_method(:matches?, "Radar::Matchers::%sMatcher",  *args)
    end

    # The callback that is used to add a filter to the {UseArray}
    # when `filters.use` is called.
    def add_filter(*args)
      callable_method(:filter, "Radar::Filters::%sFilter",  *args)
    end

    def callable_method(method, inflectorspace, *args)
      block = args.pop if args.length == 1 && args.first.is_a?(Proc)
      raise ArgumentError.new("Requires at least a class or a lambda to be given.") if args.empty? && !block
      name = block || args.first

      if !args.empty?
        klass = args.shift

        if !klass.is_a?(Class)
          space = inflectorspace % Support::Inflector.camelize(klass)
          klass = Support::Inflector.constantize(space)
        end

        # Instantiate the class and yield the block if it was given
        # with the instance.
        instance_block = args.pop if args.last.is_a?(Proc)
        instance = klass.new(*args)
        instance_block.call(instance) if instance_block

        # Store the callable method away as the callable for later.
        block = instance.method(method)
      end

      [name, block]
    end
  end

  class Config
    # A subclass of Array which allows for slightly different usage, based
    # on `ActionDispatch::MiddlewareStack` in Rails 3. The main methods are
    # enumerated below:
    #
    # - {#use}
    # - {#insert}
    # - {#insert_before}
    # - {#insert_after}
    # - {#swap}
    # - {#delete}
    #
    class UseArray
      extend Forwardable
      attr_reader :array

      def_delegators :@array, :empty?, :length, :clear

      # Initializes the UseArray with the given block used to generate
      # the value created for the {#use} method. The block given determines
      # how the {#use} method stores the key/value.
      def initialize(*args, &block)
        @array = []
        @_use_block = block || Proc.new { |key, *args| [key, key] }
      end

      # Use the given key. It is up to the configured use block (given by
      # the initializer) to generate the actual key/value stored in the array.
      def use(*args, &block)
        insert(length, *args, &block)
      end

      # Insert the given key at the given index or directly before the
      # given object (by key).
      def insert(key, *args, &block)
        args.push(block) if block
        @array.insert(index(key), @_use_block.call(*args))
      end
      alias_method :insert_before, :insert

      # Insert after the given key.
      def insert_after(key, *args, &block)
        i = index(key)
        raise ArgumentError.new("No such key found: #{key}") if !i
        insert(i + 1, *args, &block)
      end

      # Swaps out the given object at the given index or key with a new
      # object.
      def swap(key, *args, &block)
        i = index(key)
        raise ArgumentError.new("No such key found: #{key}") if !i
        delete(i)
        insert(i, *args, &block)
      end

      # Delete the object with the given key or index.
      def delete(key)
        @array.delete_at(index(key))
      end

      # Returns the value for the given key. If the key is an integer,
      # it is returned as-is. Otherwise, do a lookup on the array for the
      # the given key and return the index of it.
      def index(key)
        return key if key.is_a?(Integer)
        @array.each_with_index do |data, i|
          return i if data[0] == key
        end

        nil
      end

      # Returns the values of this array.
      def values
        @array.inject([]) do |acc, data|
          acc << data[1]
          acc
        end
      end

      # Merges one {UseArray} with another and return a new instance with
      # the values merged.
      #
      # @param [UseArray] other
      # @return [UseArray]
      def merge(other)
        result = UseArray.new(&@_use_block)
        result.array.push(*(array + other.array))
        result
      end
    end
  end
end
